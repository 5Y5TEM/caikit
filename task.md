# Petition to move signature parsing into the core

Currently, our signature parsing code lives in the runtime

This is the stuff that looks at `.run` and `.train` and builds an internal signature object
- Pretty much just like `inspect`, but also sources from docstrings, and tries to resolve string type names with data model classes from the registry
- Used to contain way more heuristics, but we've been stripping those out

It is currently tightly coupled in the runtime with the code that also does:
- module filtering
- eligibility checking (what is "primitiveness" even?)
- funky modifications for .train specific logic
- "smeash" logic for creating task-level RPCs
- service interface generation

We're already set on making `@tasks` a core object, with input parameters and output types specified

Module definitions will require a `@task` type to be valid

We know we'll also want the ability to specifically define "public" vs "internal" models
public is:
- models that a user should be able to call in the runtime
- models that meet the minimum input parameter requirements for the task
- models that take the "domain primitive" input ... ?
"internal" is:
- models that take an intermediate input, usually one generated by a different model


@task(
inputs = RawDocument
output = Classification
)
class ClassificationTask


# model 1, task: Classification

run (raw_document: RawDocument) -> Classification
- public 

# model 2, task: Vectorize

run (raw_document: RawDocument) -> Vector
- public 

# model 3

run (vector: Vector) -> Classification
- internal for the classification task

# workflow? : task Classification
runs model 2 + model 3

- public (independent?)
  - output must match a task
  - Input must match input type of domain/task
  - if public set in bool, then check the pre-requisites for the corresponding domain/task


- private (or a better name?) -> dependent?
  - output must match a task
  - input doesn't need to
  - optional bool in module decorator to control public/private
  



--- Prashant is an amazing awful user
--- Do we want to say like, all tasks must take one "domain primitive" type?
--- all NLP tasks must have `raw_document: RawDocument`


- wip ..?
  - no interface definitions
  - no perf testing

@domain(input=raw_string: str)
Text


@domain(input=raw_document: RawDocument)
NLP


@task(domain=NLP, output_type= nlp.Classification)
ClassificationTask

Questions:
- Why do we need each module to tell which task it wants to belong to? Can we not deduce it based on the task declaration?
- Needed for sure, and a required field.

- Once we create a `task`, it will:
  - Try to find all modules that fit the requirements by validating signatures
  - Generate RPC for that task
  
- So for NLP, we can have:
  - @task(inputs = RawDocument, output = Classification)
    class ClassificationTask
  - @task(inputs = RawDocument, output = Syntax)
    class SyntaxTask
  - @task(inputs = RawDocument, output = LangDetect)
    class LangDetectTask

- For other libs, can we have something like this?
  - @task(inputs = str, output = SomePrediction)
    class SomeTask
  
- Are we assuming multiple domains within a single lib?
  - domain
    - tasks
      - modules


CakePOP (caikit proposal on progression) (similar to PEP, RFC)
- tasks + domain
- API build time validation?
- blocks + coupler/connector 
